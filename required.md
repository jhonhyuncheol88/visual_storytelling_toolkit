네, 알겠습니다. AI 기능 없이, 지금까지 논의된 모든 기획 데이터를 저장하고 시각적으로 관리하는 영상 기획 툴 'CineScribe'의 기획 설계 문서를 작성해 드리겠습니다. 이 설계는 Python을 사용하여 Windows와 macOS에서 모두 작동하는 데스크톱 애플리케이션을 만드는 것을 목표로 합니다.

-----

### **프로젝트 기획 설계서: CineScribe (The Visual Storytelling Toolkit)**

#### **1. 프로젝트 개요**

**CineScribe**는 1인 창작자, 학생, 인디 필름메이커를 위한 직관적인 영상 프리 프로덕션(Pre-production) 관리 도구입니다. 복잡한 AI 기능 없이, 사용자가 직접 입력한 아이디어를 체계적으로 저장하고, 시각적으로 구성하며, 전체 프로젝트를 한눈에 파악할 수 있도록 돕는 데 집중합니다. 마치 책을 집필하듯, 아이디어의 시작부터 최종 샷 리스트까지의 모든 과정을 모듈화하여 관리하는 디지털 워크북 플랫폼입니다.

*   **목표:** 분산된 기획 자료(시나리오, 캐릭터 설정, 샷 리스트, 이미지, 오디오 아이디어 등)를 단일 프로젝트 파일로 통합 관리하고, 시각적인 스토리보드 중심으로 전체 흐름을 쉽게 파악할 수 있는 환경을 제공합니다.
*   **플랫폼:** Python 기반의 데스크톱 애플리케이션 (Windows, macOS 호환)

#### **2. 핵심 설계 철학**

*   **모듈식 구조 (Modular Design):** 기획의 각 단계를 독립적인 모듈(탭 또는 섹션)로 분리하여 사용자가 원하는 부분에 집중하고 체계적으로 작업할 수 있도록 합니다.
*   **시각 중심 인터페이스 (Visual-First Interface):** 텍스트뿐만 아니라 이미지(스토리보드, 캐릭터 아트)를 중심으로 정보를 배치하여, 사용자가 프로젝트를 직관적으로 이해하고 창의적인 영감을 얻을 수 있도록 합니다.
*   **데이터 중심 설계 (Data-Centric Architecture):** 모든 데이터는 상호 연결됩니다. 예를 들어, '캐릭터' 모듈에서 캐릭터의 이름을 변경하면 '스토리보드'의 관련 샷 설명에도 자동으로 반영되어 일관성을 유지합니다.
*   **단순성과 직관성 (Simplicity & Intuition):** 복잡한 기능 대신, 영상 기획의 핵심적인 기능에만 집중하여 누구나 쉽게 배우고 사용할 수 있도록 합니다.
*   **다작 관리 (Multi-Project Management):** 하나의 앱에서 여러 작품을 체계적으로 관리합니다. 프로젝트 라이브러리를 제공하여 작품 생성/열기/검색/태깅/아카이브를 지원하고, 개별 작품은 독립적인 단일 파일(SQLite)로 유지합니다.

#### **3. 시스템 아키텍처**

**3.1. 데이터 모델**

*   **파일 형식:** 모든 프로젝트 데이터는 단일 `.cinescribe` 파일(실제로는 SQLite 데이터베이스)에 저장됩니다. 이를 통해 사용자는 프로젝트 파일을 쉽게 공유하고 백업할 수 있습니다.
*   **데이터베이스 구조 (SQLite):**
    *   `Project_Info`: 프로젝트 제목, 로그라인, 시놉시스, 기획 의도, 검토 노트 등 저장.
    *   `Characters`: 캐릭터 ID, 이름, 설명, **캐릭터 디자인 프롬프트**, **캐릭터 이미지 경로** 등 저장.
    *   `Scenes`: 장면 번호, 장소, 시간, 요약 등 저장.
    *   `Shots`: 샷 번호(예: 1.1), 장면 ID(외래키), **스토리보드 이미지 경로**, 샷 설명, 카메라 앵글/움직임, **이미지 생성 프롬프트(7부)**, **영상 프롬프트(샷 설명)** 등 저장.
    *   `Audio_Cues`: 오디오 ID, 관련 샷 ID(외래키), 오디오 타입(BGM/SFX/테마), **Suno 스타일/가사 프롬프트(6부)** 등 저장.
    *   `Assets`: 모든 미디어 파일(이미지)의 경로와 메타데이터를 관리.
    *   `Documents`: 텍스트/JSON 기반 내러티브·노트 데이터를 키(`key`)로 관리. 예: `logline`, `synopsis`, `outline`, `notes` 등. 포맷(`format='text'|'json'`)과 원문(`content`) 저장, 내보내기(JSON/TXT) 지원.

**3.2. 애플리케이션 구조 (UI/UX)**

*   **메인 창:** 좌측에는 내비게이션 패널, 중앙에는 선택된 모듈의 작업 공간이 표시되는 2단 레이아웃을 사용합니다.

    *   **좌측 내비게이션:**
        *   프로젝트 허브 (Project Hub)
        *   캐릭터 워크숍 (Character Workshop)
        *   스토리 아웃라인 (Story Outline)
        *   **스토리보드 (Storyboard)** - 핵심 기능
        *   에셋 라이브러리 (Asset Library)
    *   **중앙 작업 공간:** 선택된 내비게이션 메뉴에 따라 해당 모듈의 UI가 동적으로 표시됩니다.

**3.3. 아키텍처 패턴 (MVC/MVVM)**

*   **모델(Model):** 도메인 객체(`Project`, `Character`, `Scene`, `Shot`, `AudioCue`, `Asset`)와 영속성 계층(Repository). SQLite 스키마와 1:1 매핑되는 데이터 클래스로 구성합니다.
*   **뷰(View):** PySide6(Qt) 위젯/뷰 컴포넌트. `QListView/QTableView/QGraphicsView` 등 Qt Model/View 체계를 사용하여 대용량에서도 성능을 확보합니다.
*   **컨트롤러/뷰모델(Controller/ViewModel):** 사용자 입력을 해석하고 모델을 갱신, 시그널/슬롯으로 뷰를 동기화합니다. 복잡 화면은 ViewModel로 상태를 관리합니다.
*   **Repository 패턴:** 데이터 접근을 캡슐화(`ProjectRepository`, `CharacterRepository` 등). 트랜잭션 단위 저장, 스키마 마이그레이션 버저닝 포함.
*   **Service 계층:** 썸네일 생성, 에셋 임포트/중복감지, 내보내기 등 횡단 관심사를 모델/컨트롤러와 분리합니다.

**3.4. 객체지향 설계 원칙(OOP)**

*   **캡슐화:** 도메인 클래스가 자신의 무결성(예: `Shot`이 유효한 `scene_id` 없이 생성되지 않도록)과 유효성 검사를 스스로 보장합니다.
*   **단일 책임 원칙(SRP):** UI 렌더링, 데이터 접근, 비즈니스 규칙, 미디어 처리 역할을 명확히 분리합니다.
*   **개방-폐쇄 원칙(OCP):** 새로운 샷 속성이나 에셋 타입 추가 시 기존 코드 수정 최소화(확장 포인트, 추상 인터페이스 사용).
*   **리스코프 치환/인터페이스 분리(LSP/ISP):** 뷰 모델 인터페이스를 좁게 유지하고 필요한 기능만 노출합니다.
*   **의존 역전 원칙(DIP):** 컨트롤러는 구체 저장소가 아닌 추상 인터페이스에 의존하고, 팩토리/주입으로 연결합니다.

도메인: `Project`는 `Characters/Scenes/Assets`의 Aggregate Root이며, 하위 엔티티는 생성/수정 시각과 정렬 인덱스를 보유합니다.

**3.5. 프로젝트 라이브러리(다작) 설계**

*   **구성:** 앱 전역 라이브러리 DB(`library.sqlite`) 또는 설정 파일에 여러 프로젝트의 메타데이터를 인덱싱: 경로, 제목, 태그, 썸네일, 최근 열람 시각, 버전.
*   **역할:** 여러 작품을 목록/검색/정렬/태깅/아카이브. 프로젝트는 탭으로 동시 열기 또는 단일 인스턴스 전환을 지원합니다.
*   **일관성:** 각 프로젝트는 독립 `.cinescribe`(SQLite) 파일 유지. 라이브러리는 참조 인덱스이므로 실파일 이동/삭제 감지 로직 포함.
*   **백업/이동:** 임포트/익스포트 시 라이브러리 인덱스 자동 갱신, 누락 경로 복구 마법사 제공합니다.

#### **4. 모듈별 상세 기능 설계**

**4.0. 프로젝트 라이브러리 (Project Library)**

*   **기능:** 여러 작품을 생성/열기/검색/태깅/아카이브. 최근 작업, 즐겨찾기, 태그 필터, 정렬(최신/제목/태그/사용량)을 제공합니다.
*   **저장 데이터(라이브러리 DB):** `project_path`, `title`, `tags`, `thumbnail`, `last_opened_at`, `created_at`, `db_version`, `archived`.
*   **UI:** 시작 화면 카드 그리드(썸네일+제목+태그+최근 열람 시간), 상단 검색/태그 칩, 새 프로젝트 생성 버튼. 컨텍스트 메뉴(복제/내보내기/아카이브/디스크에서 제거).

**4.1. 프로젝트 허브 (Project Hub)**

*   **기능:** 프로젝트의 가장 핵심적인 정보를 요약하고 관리합니다.
*   **저장 데이터:**
    *   **1부 데이터:** 프로젝트 제목, 로그라인, 시놉시스, 기획 의도.
    *   **5부 데이터:** 프로젝트 전체에 대한 검토 내용이나 메모를 자유롭게 작성할 수 있는 텍스트 필드.
    *   **문서 데이터:** 키 기반 텍스트/JSON(`Documents` 테이블) 저장. 예: `logline`, `synopsis`, `outline`, `notes`.
*   **UI:** 프로젝트 제목이 크게 표시되고, 문서 편집 툴바(문서 키 선택/직접입력, 형식 선택 text/json, 불러오기/저장/내보내기 버튼)와 텍스트 에디터로 구성됩니다. 내보내기는 JSON/TXT를 지원합니다.

**4.2. 캐릭터 워크숍 (Character Workshop)**

*   **기능:** 등장인물을 생성하고 시각적 정체성을 관리합니다.
*   **저장 데이터:**
    *   캐릭터 이름, 나이, 직업, 성격, 목표, 갈등 등 텍스트 정보.
    *   **캐릭터 디자인 프롬프트:** 해당 캐릭터의 외형, 의상 등을 묘사하는 텍스트 프롬프트 저장.
    *   **캐릭터 이미지:** 사용자가 생성하거나 찾은 캐릭터 이미지를 업로드하여 저장.
*   **UI:** 좌측에 캐릭터 목록, 우측에 선택된 캐릭터의 상세 프로필(텍스트 정보, 프롬프트, 이미지 뷰어)이 표시됩니다.

**4.3. 스토리보드 (Storyboard)**

*   **기능:** 이 프로그램의 핵심 기능으로, 각 장면을 시각적인 샷의 연속으로 구성합니다.
*   **저장 데이터:**
    *   **3부 데이터:** 샷 번호, 샷 타입, 카메라 앵글, 움직임, 렌즈, 조명 등.
    *   **6부 데이터:** 각 샷에 연결된 오디오 프롬프트 (Suno용).
    *   **7부 데이터:** 각 샷의 이미지를 만들기 위한 상세 영어 프롬프트.
    *   **사용자 요청 기능:**
        *   **스토리보드 이미지:** 사용자가 직접 그리거나 생성한 이미지를 각 샷에 업로드.
        *   **영상 프롬프트:** 샷의 핵심 액션이나 대사를 요약하는 텍스트 필드.
*   **UI:**
    *   상단에서 장면(Scene)을 선택할 수 있는 드롭다운 메뉴.
    *   선택된 장면에 포함된 샷들이 썸네일 이미지 그리드 형태로 나열됩니다.
    *   각 썸네일을 클릭하면 상세 뷰가 팝업 또는 우측 패널에 나타나며, 해당 샷의 모든 정보(이미지, 샷 설명, 카메라 정보, 이미지 프롬프트, 오디오 프롬프트)를 확인하고 편집할 수 있습니다.

**4.4. 에셋 라이브러리 (Asset Library)**

*   **기능:** 프로젝트에 사용된 모든 이미지 파일(캐릭터, 스토리보드)을 한곳에서 관리합니다.
*   **UI:** 썸네일 그리드 형태로 모든 이미지를 보여주며, 어떤 캐릭터 또는 샷에 연결되어 있는지 태그로 표시합니다.

#### **5. 기술 구현 계획 (Python)**

*   **GUI 프레임워크:** **PyQt** 또는 **PySide**를 추천합니다. 현대적인 UI를 구성하기 용이하며, Windows와 macOS에서 일관된 경험을 제공합니다. (대안: Tkinter는 기본 내장이지만 UI 커스터마이징에 한계가 있음)
*   **데이터베이스:** Python에 기본 내장된 `sqlite3` 모듈을 사용하여 단일 파일 데이터베이스를 관리합니다.
*   **이미지 처리:** `Pillow` (PIL Fork) 라이브러리를 사용하여 이미지 로드, 리사이징, 썸네일 생성 등을 처리합니다.
*   **패키징:** `PyInstaller` 또는 `cx_Freeze`를 사용하여 Python 코드를 Windows용 `.exe` 파일과 macOS용 `.app` 파일로 패키징하여 쉽게 배포할 수 있도록 합니다.
*   **아키텍처:** MVC/MVVM 적용. Qt Model/View 적극 활용, Repository/Service 계층화. 도메인 객체는 `dataclasses`와 타입 힌트를 사용합니다.
*   **다작 관리:** 전역 라이브러리 인덱스(`library.sqlite` 또는 `library.json`)로 프로젝트 메타데이터를 관리하고, 파일 감시로 유실/이동을 탐지해 자동 재인덱싱합니다.
*   **문서 저장:** `Documents` 테이블과 `DocumentService`로 키 기반 텍스트/JSON 저장/불러오기 및 내보내기(JSON/TXT) 제공.
*   **앱 시작/전환 흐름:** 시작 시 라이브러리 화면만 표시→프로젝트 열기 시 내비게이션 활성화와 `Project Hub`로 전환, 창 제목에 현재 프로젝트 경로 표시, 최근 열람 시간 자동 기록.

#### **6. 개발 로드맵**

0.  **사전 단계 (프로젝트 라이브러리 MVP):** 라이브러리 DB/파일 설계, 프로젝트 카드 그리드, 생성/열기/태깅/검색, 최근 항목.
1.  **1단계 (기초 설계 및 데이터 모델 구축):** SQLite 데이터베이스 스키마를 확정하고, 프로젝트 생성/저장/불러오기 기능을 구현합니다.
2.  **2단계 (핵심 UI 및 프로젝트 허브 구현):** 메인 창 레이아웃을 만들고, '프로젝트 허브' 모듈의 텍스트 데이터 입출력 기능을 완성합니다.
3.  **3단계 (스토리보드 뷰 구현):** 가장 핵심적인 '스토리보드' 모듈을 개발합니다. 이미지 업로드, 그리드 뷰, 상세 정보 표시 기능을 구현합니다.
4.  **4단계 (나머지 모듈 구현):** '캐릭터 워크숍'과 '에셋 라이브러리' 기능을 추가합니다.
5.  **5단계 (최적화 및 패키징):** 데이터 연동 로직을 다듬고, 버그를 수정하며, 최종 사용자용 설치 파일로 패키징합니다.

#### **7. 향후 확장 가능성**

*   **PDF/HTML로 내보내기:** 전체 기획안(시나리오, 캐릭터 시트, 스토리보드)을 하나의 문서로 출력하는 기능.
*   **타임라인 뷰:** 각 샷의 예상 길이를 입력받아 전체 영상의 러닝타임을 시뮬레이션하는 기능.
*   **AI 기능 플러그인 (선택적):** 현재는 AI 기능이 없지만, 모듈식 설계를 통해 향후 각 Gem 설계 문서의 AI 기능을 플러그인 형태로 추가할 수 있는 확장성을 가집니다.